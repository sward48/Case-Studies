---
title: "Hamden Appraised Value 'Fairness', Part 2: Data Acquisition"
format: html
---

As some of you found, the state-wide data from 2024 is missing sale prices for Hamden for some reason. The state-wide data from 2023 that we used in class last spring does have sale prices for Hamden. I wrongly assumed the 2024 data would be fine since the 2023 data was fine. Rookie mistake!

We could potentially use the 2023 data to do the analysis, but maybe we'd want more recent data. We can obtain this data directly from the Vision's website https://gis.vgsi.com/hamdenct/. On that website there is one webpage for every property. For example, here is the first Hamden property from the first row of the state-wide dataset (after filtering for `Town.Name == 'Hamden'` with property ID (PID) equal to 1: <https://gis.vgsi.com/hamdenct/Parcel.aspx?Pid=1>. Among other things, the HTML pages contain information appraised value (most recent, and a short history), sale date and price for recent transactions, and information about the property that we have seen previous (bedrooms, square footage of living area, etc). This info is unfortunately not in one nice neat table, but the information can be extracted and put into a data frame.

[This .zip file](https://yaleedu-my.sharepoint.com/:u:/g/personal/brian_macdonald_yale_edu/ERDOKwhS_s1Bn2f3GFAg5gABBrtaf-g-bAsOetpW44j7yA?e=QHhBRf) contains one HTML file for almost all of the properties in Hamden, so you don't have to spend the time to scrape them all. Extract the information you need to assess the "fairness" of the appraised values that were determined by Vision. To extract that information, you can likely use some combination of regular expressions and functions that read HTML tables like those summarized here: <https://bmacgtpm.github.io/notes/parsing-html-tables.html>.

```{r}
library(readxl)
library(dplyr)
library(janitor)
library(ggplot2)
```

```{r}
# # read the csv file
# ct <- read.csv("Connecticut_CAMA_and_Parcel_Layer_3895368049124948111.csv")

# # filter the ct with Town_name = Hamden
# ct <- ct %>% filter(Town_Name == "Hamden")

# # save as rds
# saveRDS(ct, file = "hamden.RDS") 
```


# Scraping of the HTML files
Keep the html directory "Hamden_Sept2025" in the working directory.

```{r, eval=FALSE} 
# eval=FALSE to avoid re-running the scraping

# read html file from Hamden_Sept2025
library(rvest)

# file from the zip file
files <- list.files("Hamden_Sept2025", pattern = "*.html", full.names = TRUE)

df <- data.frame() # to collect values from each html
skips <- c() # to collect skipped file numbers

# "Hamden_Sept2025/100045.html"

for (file in files){
    d1 <- read_html(file) 
    d2 <- d1 %>% html_table()
    html_lines <- strsplit(as.character(d1), "\n")[[1]]

    if (length(d2) < 6) { # skip if no table
        # append file number before .html to skips
        skips <- c(skips, gsub(".*\\/|\\.html", "", file))
        next
    }

    # get the line number with PID
    line_PID <- grep("PID", lines)

    # PID from the file, 3rd row after the line with PID
    pid <- gsub("<.*?>", "", html_lines[line_PID+3]) %>% trimws()
    pid <- as.numeric(pid) # make numeric

    # 2024 assessed value
    assessed_2024 <- d2[3]
    assessed_2023 <- d2[length(d2)]  # 2023 is the last table

    # Sale prices
    sale_prices <- d2[[6]]

    building_2023 <- as.numeric(gsub("[$,]", "", assessed_2023[[1]][2]))
    extra_2023 <- as.numeric(gsub("[$,]", "", assessed_2023[[1]][3]))
    outb_2023 <- as.numeric(gsub("[$,]", "", assessed_2023[[1]][4]))
    land_2023 <- as.numeric(gsub("[$,]", "", assessed_2023[[1]][5]))
    total_2023 <- as.numeric(gsub("[$,]", "", assessed_2023[[1]][6]))

    building_2024 <- as.numeric(gsub("[$,]", "", assessed_2024[[1]][2]))
    extra_2024 <- as.numeric(gsub("[$,]", "", assessed_2024[[1]][3]))
    outb_2024 <- as.numeric(gsub("[$,]", "", assessed_2024[[1]][4]))
    land_2024 <- as.numeric(gsub("[$,]", "", assessed_2024[[1]][5]))
    total_2024 <- as.numeric(gsub("[$,]", "", assessed_2024[[1]][6]))

    sale_df <- as.data.frame(sale_prices)
    sale_df["Sale Price"] <- as.numeric(gsub("[$,]", "", sale_df[,"Sale Price"]))
    sale_df["Sale Date"] <- as.Date(sale_df[,"Sale Date"], format = "%m/%d/%Y")

    # select the most recent sale above 1000
    if (nrow(sale_df) > 1 & any(sale_df$`Sale Price` > 1000)){
        sale_df <- sale_df %>% 
            filter(`Sale Price` > 1000) %>% 
            arrange(desc(`Sale Date`))
    }
    sale_price <- sale_df[1, "Sale Price"]
    sale_date <- sale_df[1, "Sale Date"]

    # add to the data frame
    property <- data.frame(
        pid = pid,
        sale_price = sale_price,
        sale_date = sale_date,
        total_2024 = total_2024,
        total_2023 = total_2023,
        building_2024 = building_2024,
        building_2023 = building_2023,
        extra_2024 = extra_2024,
        extra_2023 = extra_2023,
        outb_2024 = outb_2024,
        outb_2023 = outb_2023,
        land_2024 = land_2024,
        land_2023 = land_2023
    )

    df <- rbind(df, property)

    if (nrow(df) %% 1000 == 0){
        cat(nrow(df), " ")
    }
}
if (length(skips) > 0){
    print(paste("Skipped a total of", length(skips), "files"))
} else {
    print("No files were skipped")
}

# order df by pid
df <- df %>% arrange(pid)

# save to csv file
write.csv(df, "sales_scraped.csv", row.names = FALSE)
```


Plot histogram of sale years with sale_price > 10000 (after 2010)

```{r}
df <- read.csv("sales_scraped.csv")
df$sale_date <- as.Date(df$sale_date)

df$years <- as.numeric(format(df$sale_date, "%Y"))

# histogram of years with sale_price > 10000 (after 2010), bars centered at integers
hist(df$years[df$years >= 2008 & df$sale_price>10000], xlab = "Year", main="", breaks = seq(2007.5, 2025.5, by=1))
box()

# save as pdf
dev.copy2pdf(file = "figures/year_hist.pdf", width = 7, height = 5)
```

# Preliminary analysis of the data
Load the data and plot distribution of assessed value / sale price

```{r}
hamden <- readRDS("data/hamden.RDS") %>% clean_names()
sales <- read.csv("sales_scraped.csv")
geo <- readRDS("centroids.no.geometry.rds") %>% 
    filter(Town_Name == "HAMDEN") %>%
    mutate(pid = as.integer(gsub("35650-", "", Link))) %>%
    filter(!is.na(pid)) %>%
    select(pid, locatio=Location, lon = point.x, lat = point.y)

property_keep <- c(
  "pid", #"link", 
  "land_acres", "living_area", "effective_area", "total_rooms", "number_of_bedroom",
  "number_of_baths", "number_of_half_baths", "occupancy", "ayb", "eyb",
  "shape_area", "shape_length"
)
hamden <- hamden %>%
    mutate(pid = as.integer(gsub("35650-", "", link))) %>%
    filter(!is.na(pid)) %>%
    select(all_of(property_keep))

# merge on pid (keep all properties; bring in sales/appraisal cols)
merged <- hamden %>% 
    left_join(sales, by = "pid") %>%
    left_join(geo, by = "pid") 


# sanity check: compare assessed value in the property dataset and the scraped sales dataset
# head(merged[, c("pre_yr_assessed_total", "assessed_total", "total_2024", "total_2023")],10)
```

Filter the data to sales in 2023 and 2024, and filtering outliers with assessment ratio > 2

```{r}
# Remove rows with sale_price=0 
merged <- merged[merged["sale_price"] != 0, ]

sold_2023 <- merged %>% 
    filter(!is.na(sale_price), 
           !is.na(total_2023),
           !is.na(sale_date),
           as.numeric(format(as.Date(sale_date), "%Y")) == 2023) %>%
    mutate(ratio = total_2023 / sale_price) #%>%
    #filter(ratio < 2) # remove outliers with ratio > 2
sold_2024 <- merged %>% 
    filter(!is.na(sale_price), 
           !is.na(total_2024),
           !is.na(sale_date),
           as.numeric(format(as.Date(sale_date), "%Y")) == 2024) %>%
    mutate(ratio = total_2024 / sale_price) #%>%
    #filter(ratio < 2) # remove outliers with ratio > 2
```

Combine 2023 and 2024 data to plot histogram of the assessment ratio (for both years)

```{r}
sold_2023_2024 <- rbind(sold_2023, sold_2024)

# sales in 2023 and 2024
hist(sold_2023_2024$ratio, breaks = 50, xlim = c(0, 2),
     xlab = "Assessed Value / Sale Price", main="",
     border = "grey", )
abline(v = 0.7, col = "red", lty = 1)
abline(v = median(sold_2023_2024$ratio, na.rm = TRUE), col = "blue", lty = 2)
legend("topright", legend = c("0.7 line", "Median"), col = c("red", "blue"), lty = 1)
box(col = "black")

# save as pdf
dev.copy2pdf(file = "figures/ratio_2023_2024.pdf", width = 7, height = 5)
```

To compare the distributions of the assessment ratio for 2023 and 2024, the densities are compared below.

```{r}
# Density plots for 2023 and 2024 
plot(density(sold_2023$ratio, na.rm = TRUE), col = "blue", lwd = 2,
     xlim = c(0, 2), ylim = c(0, 6),
     xlab = "Assessed Value / Sale Price", ylab = "Density",
     main = "")
lines(density(sold_2024$ratio, na.rm = TRUE), col = "red", lwd = 2)
abline(v = 0.7, col = "black", lty = 2, lwd = 1.5)
abline(v = median(sold_2023$ratio, na.rm = TRUE), col = "blue", lty = 3, lwd = 1.5)
abline(v = median(sold_2024$ratio, na.rm = TRUE), col = "red", lty = 3, lwd = 1.5)
legend("topright", legend = c("2023", "2024", "0.7 line"), 
       col = c("blue", "red", "black"), lty = c(1, 1, 2), lwd = c(2, 2, 1.5))

# save as pdf
dev.copy2pdf(file = "figures/density_2023_2024.pdf", width = 7, height = 5)
```

And associated table with the figures above

```{r}
# Summary table with mean, median, sd of ratio for 2023 and 2024
year_table <- data.frame(Year = c(2023, 2024, "Overall"),
      Mean = c(mean(sold_2023$ratio, na.rm = TRUE), mean(sold_2024$ratio, na.rm = TRUE), mean(sold_2023_2024$ratio, na.rm = TRUE)),
      Median = c(median(sold_2023$ratio, na.rm = TRUE), median(sold_2024$ratio, na.rm = TRUE), median(sold_2023_2024$ratio, na.rm = TRUE)),
      SD = c(sd(sold_2023$ratio, na.rm = TRUE), sd(sold_2024$ratio, na.rm = TRUE), sd(sold_2023_2024$ratio, na.rm = TRUE))
)

# print table and round to 3 decimal places
year_table <- year_table %>%
    mutate(across(c(Mean, Median, SD), ~ round(., 3)))
year_table
```


# Feature analysis: bedrooms, living area, sale price
```{r}
# Two way table with number_of_bedroom and 2023 and 2024, median ratio
# for bedrooms 1:7
bedroom_table <- data.frame(
    Bedrooms = 1:7,
    Count_2023 = sapply(1:7, function(x) sum(sold_2023$number_of_bedroom == x, na.rm = TRUE)),
    Median_2023 = sapply(1:7, function(x) median(sold_2023$ratio[sold_2023$number_of_bedroom == x], na.rm = TRUE)),
    Count_2024 = sapply(1:7, function(x) sum(sold_2024$number_of_bedroom == x, na.rm = TRUE)),
    Median_2024 = sapply(1:7, function(x) median(sold_2024$ratio[sold_2024$number_of_bedroom == x], na.rm = TRUE))
)
bedroom_table <- bedroom_table %>%
    mutate(across(c(Median_2023, Median_2024), ~ round(., 3)))
bedroom_table

# remove bedroom count = 1
bedroom_table <- bedroom_table[bedroom_table$Bedrooms != 1, ]

sold_2023 <- sold_2023 %>% 
    # 1 beds set into 2 and above 6 merged into bedroom 6
    mutate(beds2_6 = case_when(
        number_of_bedroom <= 2 ~ 2,
        number_of_bedroom >= 6 ~ 6,
        TRUE ~ number_of_bedroom
    ))
sold_2024 <- sold_2024 %>%
    # 1 beds set into 2 and above 6 merged into bedroom 6
    mutate(beds2_6 = case_when(
        number_of_bedroom <= 2 ~ 2,
        number_of_bedroom >= 6 ~ 6,
        TRUE ~ number_of_bedroom
    ))

# boxplot with for 2023 and 2024 (just for 2-7 bedrooms)
boxplot(ratio ~ factor(beds2_6), 
        data = sold_2023,
        at = rep(1:5) + c(-0.15),
        col = c("lightblue"),
        xlab = "Number of Bedrooms", ylab = "Assessed / Sale Price",
        main = "",
        boxwex = 0.25, 
        ylim = c(0, 2),
        xaxt = "n") # remove xlabels
boxplot(ratio ~ factor(beds2_6), 
        data = sold_2024,
        at = rep(1:5) + c(+0.15),
        col = c("lightpink"),
        boxwex = 0.25,
        xaxt = "n", # remove xlabels
        add=TRUE) 
abline(h = 0.7, col = "grey4", lty = 2, lwd = 1)
axis(1, c(1:5), labels = c("<=2", 3, 4, 5, ">=6"))
text(0.5, 0.76, "0.7 Line", col = "black", cex = 0.8)
box()
legend("topright", legend = c("2023", "2024"), fill = c("lightblue", "lightpink"))

# save as pdf
dev.copy2pdf(file = "figures/boxplot_bedrooms.pdf", width = 7, height = 5)
```


```{r}
sold_2023_living <- sold_2023 %>% 
    filter(!is.na(living_area), living_area > 100)
sold_2024_living <- sold_2024 %>% 
    filter(!is.na(living_area), living_area > 100)

# Fir a log-log linear models
lm_living23 <- lm(log(ratio) ~ log(living_area), data = sold_2023_living)
lm_living24 <- lm(log(ratio) ~ log(living_area), data = sold_2024_living)

# Plot points and regression lines for 2023
plot(log(sold_2023_living$living_area), log(sold_2023_living$ratio), 
     xlab = "Living Area (log sq ft)", ylab = "Assessed / Sale Price (log)",
     pch = 19, col = alpha(rgb(0, 0, 1, 0.3),0.2), cex=0.6)
abline(lm_living23, col = "blue", lwd = 2)

# and 2024 on the same plot (transparent points)
points(log(sold_2024_living$living_area), log(sold_2024_living$ratio), 
       pch = 19, col = alpha(rgb(1, 0, 0, 0.3),0.2), cex=0.6)
abline(lm_living24, col = "red", lwd = 2)
legend("topright", legend = c("2023", "2024"), col = c("blue", "red"), lty = 1, lwd = 2)

# save as pdf
dev.copy2pdf(file = "figures/living_area_loglog.pdf", width = 7, height = 5)

```



```{r}
lm_sales23 <- lm(log(ratio) ~ log(sale_price), data = sold_2023)
lm_sales24 <- lm(log(ratio) ~ log(sale_price), data = sold_2024)

# Plot points and regression lines for 2023
plot(log(sold_2023$sale_price), log(sold_2023$ratio), 
     xlab = "Sale Price (log $)", ylab = "Assessed/Sale Price (log)",
     pch = 19, col = alpha(rgb(0, 0, 1, 0.3),0.2), cex=0.6)
abline(lm_sales23, col = "blue", lwd = 2)

# and 2024 on the same plot (transparent points)
points(log(sold_2024$sale_price), log(sold_2024$ratio), 
       pch = 19, col = alpha(rgb(1, 0, 0, 0.3),0.2), cex=0.6)
abline(lm_sales24, col = "red", lwd = 2)
legend("topright", legend = c("2023", "2024"), col = c("blue", "red"), lty = 1, lwd = 2)

# save as pdf
dev.copy2pdf(file = "figures/sale_price_loglog.pdf", width = 7, height = 5)
```

# Hypothesis tests

```{r}
# fit a t-test (the data is approximately normal for 2023 and 2024 but not for the combined data) for each year separately
t.test(sold_2023$ratio, mu = 0.70)
t.test(sold_2024$ratio, mu = 0.70)

# Wilcoxon signed rank test (non-parametric), for the combined data since the distribution is not normal
wilcox.test(sold_2023_2024$ratio - 0.70, conf.int = TRUE)
```

