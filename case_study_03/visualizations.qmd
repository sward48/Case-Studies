---
title: "Hamden Appraised Value 'Fairness', Part 2: Data Acquisition"
format: html
---

# Introduction

The state of Connecticut compiles property data from municipalities across the state and provides it for viewing and downloading on the state government website's CT Geodata Portal https://geodata.ct.gov/pages/parcels. Data can also be obtained from the property value assessor's website. For example, here is the website for Hamden, CT: https://gis.vgsi.com/hamdenct/.

The file Connecticut_CAMA_and_Parcel_Layer_3895368049124948111 contains data obtained from CT. The property data contain information like location, mailing address, assessed property value, size of the plot of land in acres, floor space in sq ft, whether the property is commercial or residential, etc., and for homes it has details like number of bedrooms, number of bathrooms, etc., and the most recent sale price for each property, and the date of the sale. This is similar to the data you saw in S&DS 361/661, except we aren't providing shapefiles for the property boundaries.

The sales_data.xlsx file contains sales data for recent property sales. It is not known whether this data contains more, less, or the same sales information that is contained in the property data.

# Your goals

A Hamden resident who recently purchased his house had his assessed property value significantly increase within a year of the purchase. He began to question whether the assessed value was fair. He would like to use data to see if there is any evidence he could use to contest his assessed value.

Your goal is determine whether the assessed values for residential properties in Hamden, CT are fair and determine if there is any evidence to support contesting the assessed value. Write up your analysis and submit a short PDF report on explaining your reasoning.

Note that when an assessment company decides on a new set of assessed values for properties in a given year (typically using some sort of model), they do a sanity check and compare their assessed values to actual sale prices from the past year.

As some of you found, the state-wide data from 2024 is missing sale prices for Hamden for some reason. The state-wide data from 2023 that we used in class last spring does have sale prices for Hamden. I wrongly assumed the 2024 data would be fine since the 2023 data was fine. Rookie mistake!

We could potentially use the 2023 data to do the analysis, but maybe we'd want more recent data. We can obtain this data directly from the Vision's website https://gis.vgsi.com/hamdenct/. On that website there is one webpage for every property. For example, here is the first Hamden property from the first row of the state-wide dataset (after filtering for `Town.Name == 'Hamden'` with property ID (PID) equal to 1: <https://gis.vgsi.com/hamdenct/Parcel.aspx?Pid=1>. Among other things, the HTML pages contain information appraised value (most recent, and a short history), sale date and price for recent transactions, and information about the property that we have seen previous (bedrooms, square footage of living area, etc). This info is unfortunately not in one nice neat table, but the information can be extracted and put into a data frame.

[This .zip file](https://yaleedu-my.sharepoint.com/:u:/g/personal/brian_macdonald_yale_edu/ERDOKwhS_s1Bn2f3GFAg5gABBrtaf-g-bAsOetpW44j7yA?e=QHhBRf) contains one HTML file for almost all of the properties in Hamden, so you don't have to spend the time to scrape them all. Extract the information you need to assess the "fairness" of the appraised values that were determined by Vision. To extract that information, you can likely use some combination of regular expressions and functions that read HTML tables like those summarized here: <https://bmacgtpm.github.io/notes/parsing-html-tables.html>.

Folder data: - `sales_scraped.csv`: sales data scraped from the HTML files

```{r}
# make a figures directory if it doesn't exist
if (!dir.exists("figures")){
    dir.create("figures")
}
```

```{r}
library(readxl)
library(dplyr)
library(janitor)
library(ggplot2)
library(stringr)
library(rvest)
library(purrr)
library(forcats)
library(scales)

library(plotrix) # for plotCI (plot confidence intervals)

```

# Preliminary analysis of the data

Load the data and plot distribution of assessed value / sale price

```{r}
hamden <- readRDS("data/hamden.RDS") %>% clean_names()
sales <- read.csv("data/sales_scraped.csv")
# geo <- readRDS("centroids.no.geometry.rds") %>% 
#     filter(Town_Name == "HAMDEN") %>%
#     mutate(pid = as.integer(gsub("35650-", "", Link))) %>%
#     filter(!is.na(pid)) %>%
#     select(pid, locatio=Location, lon = point.x, lat = point.y)

property_keep <- c(
  "pid", #"link", 
  "land_acres", "living_area", "effective_area", "total_rooms", "number_of_bedroom",
  "number_of_baths", "number_of_half_baths", "occupancy", "ayb", "eyb",
  "shape_area", "shape_length"
)
hamden <- hamden %>%
    mutate(pid = as.integer(gsub("35650-", "", link))) %>%
    filter(!is.na(pid)) %>%
    select(all_of(property_keep))

# merge on pid (keep all properties; bring in sales/appraisal cols)
merged <- hamden %>% 
    left_join(sales, by = "pid") # %>% left_join(geo, by = "pid") 

data_2009 <- read.csv("rawdata/Hamden2009.csv") %>%
  left_join(sales[, c("pid", "sale_price_2009", "sale_date_2009")], by = "pid") %>%
  rename(sale_price = sale_price_2009, sale_date = sale_date_2009)

```

Filter the data to sales in 2023 and 2024, and filtering outliers with assessment ratio greater than 5

```{r}
# Remove rows with sale_price=0 
merged <- merged[merged["sale_price"] != 0, ]

sold_2009 <- data_2009 %>%
  filter(!is.na(sale_price)) %>%
  mutate(ratio = assessedvalue / sale_price) %>%
  filter(ratio < 5) # remove outliers with ratio > 5

sold_2023 <- merged %>% 
    filter(!is.na(sale_price), 
           !is.na(total_2023),
           !is.na(sale_date),
           as.numeric(format(as.Date(sale_date), "%Y")) == 2023) %>%
    mutate(ratio = total_2023 / sale_price) %>%
    filter(ratio < 5) # remove outliers with ratio > 5
sold_2024 <- merged %>% 
    filter(!is.na(sale_price), 
           !is.na(total_2024),
           !is.na(sale_date),
           as.numeric(format(as.Date(sale_date), "%Y")) == 2024) %>%
    mutate(ratio = total_2024 / sale_price) %>%
    filter(ratio < 5) # remove outliers with ratio > 5
```

Combine 2023 and 2024 data to plot histogram of the assessment ratio (for both years)

```{r}
sold_2023_2024 <- rbind(sold_2023, sold_2024)

# Dataframe for all years
sold_2009_23_24 <- rbind(
  data.frame(year = 2009, ratio = sold_2009$ratio),
  data.frame(year = 2023, ratio = sold_2023$ratio),
  data.frame(year = 2024, ratio = sold_2024$ratio)
)

# sales in 2023 and 2024
hist(sold_2009_23_24$ratio, breaks = 50, xlim = c(0, 2),
     xlab = "Assessed Value / Sale Price", main="",
     border = "grey", )
abline(v = 0.7, col = "red", lty = 1)
abline(v = median(sold_2023_2024$ratio, na.rm = TRUE), col = "blue", lty = 2)
legend("topright", legend = c("0.7 line", "Median"), col = c("red", "blue"), lty = 1)
box(col = "black")

# save as pdf
dev.copy2pdf(file = "figures/ratio_2009_23_24.pdf", width = 7, height = 5)
```

To compare the distributions of the assessment ratio for 2023 and 2024, the densities are compared below.

```{r}
# Density plots for 2023 and 2024 
plot(density(sold_2009$ratio, na.rm = TRUE), col = "green", lwd = 2,
     xlim = c(0, 2), ylim = c(0, 6),
     xlab = "Assessed Value / Sale Price", ylab = "Density",
     main = "")
lines(density(sold_2023$ratio, na.rm = TRUE), col = "blue", lwd = 2)
lines(density(sold_2024$ratio, na.rm = TRUE), col = "red", lwd = 2)
abline(v = 0.7, col = "black", lty = 2, lwd = 2)
abline(v = median(sold_2009$ratio, na.rm = TRUE), col = "green", lty = 3, lwd = 1.5)
abline(v = median(sold_2023$ratio, na.rm = TRUE), col = "blue", lty = 3, lwd = 1.5)
abline(v = median(sold_2024$ratio, na.rm = TRUE), col = "red", lty = 3, lwd = 1.5)
legend("topright", legend = c("2009", "2023", "2024", "0.7 line"), 
       col = c("green","blue", "red", "black"), lty = c(1, 1, 1, 2), lwd = c(2, 2, 2, 2))

# save as pdf
dev.copy2pdf(file = "figures/density_2009_23_24.pdf", width = 7, height = 5)
```

And associated table with the figures above

```{r}
# Summary table with mean, median, sd of ratio for 2023 and 2024
year_table <- data.frame(Year = c(2009, 2023, 2024, "2023-24"),
      Mean = c(mean(sold_2009$ratio, na.rm = TRUE), mean(sold_2023$ratio, na.rm = TRUE), mean(sold_2024$ratio, na.rm = TRUE), mean(sold_2023_2024$ratio, na.rm = TRUE)),
      Median = c(median(sold_2009$ratio, na.rm = TRUE), median(sold_2023$ratio, na.rm = TRUE), median(sold_2024$ratio, na.rm = TRUE), median(sold_2023_2024$ratio, na.rm = TRUE)),
      SD = c(sd(sold_2009$ratio, na.rm = TRUE), sd(sold_2023$ratio, na.rm = TRUE), sd(sold_2024$ratio, na.rm = TRUE), sd(sold_2023_2024$ratio, na.rm = TRUE))
)

# print table and round to 3 decimal places
year_table <- year_table %>%
    mutate(across(c(Mean, Median, SD), ~ round(., 3)))
year_table
```

# Feature analysis: bedrooms, living area, sale price

```{r}
# BEDROOMS-------------------------------------------------------------
# Two way table with number_of_bedroom and 2023 and 2024, median ratio
# for bedrooms 1:7
bedroom_table <- data.frame(
    Bedrooms = 1:7,
    Count_2023 = sapply(1:7, function(x) sum(sold_2023$number_of_bedroom == x, na.rm = TRUE)),
    Median_2023 = sapply(1:7, function(x) median(sold_2023$ratio[sold_2023$number_of_bedroom == x], na.rm = TRUE)),
    Count_2024 = sapply(1:7, function(x) sum(sold_2024$number_of_bedroom == x, na.rm = TRUE)),
    Median_2024 = sapply(1:7, function(x) median(sold_2024$ratio[sold_2024$number_of_bedroom == x], na.rm = TRUE))
)
bedroom_table <- bedroom_table %>%
    mutate(across(c(Median_2023, Median_2024), ~ round(., 3)))
bedroom_table

# remove bedroom count = 1
bedroom_table <- bedroom_table[bedroom_table$Bedrooms != 1, ]

sold_2023 <- sold_2023 %>% 
    # 1 beds set into 2 and above 6 merged into bedroom 6
    mutate(beds2_6 = case_when(
        number_of_bedroom <= 2 ~ 2,
        number_of_bedroom >= 6 ~ 6,
        TRUE ~ number_of_bedroom
    ))
sold_2024 <- sold_2024 %>%
    # 1 beds set into 2 and above 6 merged into bedroom 6
    mutate(beds2_6 = case_when(
        number_of_bedroom <= 2 ~ 2,
        number_of_bedroom >= 6 ~ 6,
        TRUE ~ number_of_bedroom
    ))

# boxplot with for 2023 and 2024 (just for 2-7 bedrooms)
boxplot(ratio ~ factor(beds2_6), 
        data = sold_2023,
        at = rep(1:5) + c(-0.15),
        col = c("lightblue"),
        xlab = "Number of Bedrooms", ylab = "Assessed / Sale Price",
        main = "",
        boxwex = 0.25, 
        ylim = c(0, 2),
        xaxt = "n") # remove xlabels
boxplot(ratio ~ factor(beds2_6), 
        data = sold_2024,
        at = rep(1:5) + c(+0.15),
        col = c("lightpink"),
        boxwex = 0.25,
        xaxt = "n", # remove xlabels
        add=TRUE) 
abline(h = 0.7, col = "grey4", lty = 2, lwd = 1)
axis(1, c(1:5), labels = c("<=2", 3, 4, 5, ">=6"))
text(0.5, 0.76, "0.7 Line", col = "black", cex = 0.8)
box()
legend("topright", legend = c("2023", "2024"), fill = c("lightblue", "lightpink"))
# save as pdf
dev.copy2pdf(file = "figures/boxplot_bedrooms.pdf", width = 7, height = 5)
```


```{r}
# BATHROOMS-------------------------------------------------------------  
# total = full + 0.5 * half; bucket to 6 categories
add_bath_groups <- function(df) {
  nh <- ifelse(is.na(df$number_of_half_baths), 0, df$number_of_half_baths)
  bt <- df$number_of_baths + 0.5 * nh
  df$baths_total <- bt
  df$baths_grp <- cut(bt,
                      breaks = c(-Inf, 1.5, 2, 2.5, 3, 3.5, Inf),
                      labels = c("≤1.5", "2", "2.5", "3", "3.5", "≥4"),
                      right = TRUE)
  df
}
sold_2023 <- sold_2023 |> add_bath_groups() 
sold_2024 <- sold_2024 |> add_bath_groups()
                        
# ---- Table
bath_levels <- c("≤1.5","2","2.5","3","3.5","≥4")

bath_table <- data.frame(
  Baths = bath_levels,
  Count_2023  = sapply(bath_levels, function(g) sum(sold_2023$baths_grp == g, na.rm = TRUE)),
  Median_2023 = sapply(bath_levels, function(g) median(sold_2023$ratio[sold_2023$baths_grp == g], na.rm = TRUE)),
  Count_2024  = sapply(bath_levels, function(g) sum(sold_2024$baths_grp == g, na.rm = TRUE)),
  Median_2024 = sapply(bath_levels, function(g) median(sold_2024$ratio[sold_2024$baths_grp == g], na.rm = TRUE))
)
bath_table$Median_2023 <- round(bath_table$Median_2023, 3)
bath_table$Median_2024 <- round(bath_table$Median_2024, 3)
bath_table

## ---- Bathrooms Plot
n <- length(bath_levels)
par(mar = c(4.5, 4.5, 2, 1))
boxplot(ratio ~ baths_grp,
        data = subset(sold_2023, !is.na(baths_grp)),
        at = (1:n) - 0.15, col = "lightblue",
        xlab = "Total bathrooms (full + 0.5×half)",
        ylab = "Assessed / Sale Price",
        main = "", boxwex = 0.25, ylim = c(0, 2), xaxt = "n")
boxplot(ratio ~ baths_grp,
        data = subset(sold_2024, !is.na(baths_grp)),
        at = (1:n) + 0.15, col = "lightpink",
        boxwex = 0.25, xaxt = "n", add = TRUE)
abline(h = 0.7, col = "grey4", lty = 2, lwd = 1)
axis(1, at = 1:n, labels = bath_levels)
box(); legend("topright", legend = c("2023", "2024"),
              fill = c("lightblue", "lightpink"), bty = "n")

# save
dev.copy2pdf(file = "figures/boxplot_bathrooms.pdf", width = 7, height = 5)
```


```{r}                
# OVERALL ROOMS-------------------------------------------------------------       
# --- Rooms: bucket to ≤4, 5, 6, 7, 8, ≥9
add_room_groups <- function(df) {
  tr <- df$total_rooms
  df$rooms_grp <- cut(tr,
                      breaks = c(-Inf, 4, 5, 6, 7, 8, Inf),
                      labels = c("≤4", "5", "6", "7", "8", "≥9"),
                      right = TRUE)
  df
}

sold_2023 <- sold_2023 |> add_room_groups()
sold_2024 <- sold_2024 |> add_room_groups()

# ---- Table
room_levels <- c("≤4","5","6","7","8","≥9")

rooms_table <- data.frame(
  Rooms = room_levels,
  Count_2023  = sapply(room_levels, function(g) sum(sold_2023$rooms_grp == g, na.rm = TRUE)),
  Median_2023 = sapply(room_levels, function(g) median(sold_2023$ratio[sold_2023$rooms_grp == g], na.rm = TRUE)),
  Count_2024  = sapply(room_levels, function(g) sum(sold_2024$rooms_grp == g, na.rm = TRUE)),
  Median_2024 = sapply(room_levels, function(g) median(sold_2024$ratio[sold_2024$rooms_grp == g], na.rm = TRUE))
)
rooms_table$Median_2023 <- round(rooms_table$Median_2023, 3)
rooms_table$Median_2024 <- round(rooms_table$Median_2024, 3)
rooms_table

## ---- Rooms Plot
n <- length(room_levels)
par(mar = c(4.5, 4.5, 2, 1))
boxplot(ratio ~ rooms_grp,
        data = subset(sold_2023, !is.na(rooms_grp)),
        at = (1:n) - 0.15, col = "lightblue",
        xlab = "Total rooms",
        ylab = "Assessed / Sale Price",
        main = "", boxwex = 0.25, ylim = c(0, 2), xaxt = "n")
boxplot(ratio ~ rooms_grp,
        data = subset(sold_2024, !is.na(rooms_grp)),
        at = (1:n) + 0.15, col = "lightpink",
        boxwex = 0.25, xaxt = "n", add = TRUE)
abline(h = 0.7, col = "grey4", lty = 2, lwd = 1)
axis(1, at = 1:n, labels = room_levels)
box(); legend("topright", legend = c("2023", "2024"),
              fill = c("lightblue", "lightpink"), bty = "n")

# save
dev.copy2pdf(file = "figures/boxplot_rooms.pdf", width = 7, height = 5)
```

```{r}
# MEDIAN WITH BOOTSTRAPPING FOR DIFFERENT NUMBER OF ROOMS
# --- helper: bootstrap CI for the median -------------------------------------
boot_median_ci <- function(x, B = 2000, conf = 0.95) {
  x <- x[is.finite(x)]
  n <- length(x)
  if (n == 0) return(c(NA_real_, NA_real_, NA_real_))
  if (n < 3)  return(c(NA_real_, median(x), NA_real_))
  meds <- replicate(B, median(sample(x, n, replace = TRUE)))
  lo <- as.numeric(quantile(meds, (1 - conf)/2, names = FALSE))
  hi <- as.numeric(quantile(meds, 1 - (1 - conf)/2, names = FALSE))
  c(lo, median(x), hi)
}

# --- summarise one dataset by a factor column into median + CI ----------------
summarise_group_median <- function(df, group_col, resp = "ratio", levels = NULL, year_label = "2024") {
  group_col <- as.character(substitute(group_col))
  
  out <- df %>%
    filter(is.finite(.data[[resp]]), !is.na(.data[[group_col]])) %>%
    group_by(.data[[group_col]]) %>%
    summarise(
      n = n(),
      ci = list(boot_median_ci(.data[[resp]])),
      .groups = "drop"
    ) %>%
    mutate(
      lo  = map_dbl(ci, ~ .x[1]),
      med = map_dbl(ci, ~ .x[2]),
      hi  = map_dbl(ci, ~ .x[3])
    ) %>%
    select(-ci) %>%
    mutate(year = year_label)

  # enforce nice ordering if levels provided
  if (!is.null(levels)) {
    out[[group_col]] <- factor(out[[group_col]], levels = levels)
  }
  out
}

# ============================================================================ #
# BATHROOM GROUPS 
# ============================================================================ #

bath_levels <- c("≤1.5","2","2.5","3","3.5","≥4")

bath_23 <- summarise_group_median(sold_2023, baths_grp, resp = "ratio", levels = bath_levels, year_label = "2023")
bath_24 <- summarise_group_median(sold_2024, baths_grp, resp = "ratio", levels = bath_levels, year_label = "2024")
bath_sum <- bind_rows(bath_23, bath_24) %>%
  mutate(x_num = as.numeric(baths_grp))  # numeric x for ribbons

# Plot: median points + shaded CI ribbons + connecting lines
ggplot(bath_sum, aes(x = x_num, y = med, color = year, fill = year, group = year)) +
  geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.15, color = NA) +
  geom_line(size = 0.8) +
  geom_point(aes(size = n), alpha = 0.8) +
  scale_size_continuous(range = c(2, 6), guide = "none") +
  geom_hline(yintercept = 0.70, linetype = 2, color = "firebrick") +
  scale_x_continuous(breaks = seq_along(bath_levels), labels = bath_levels) +
  scale_color_manual(values = c("2023" = "steelblue", "2024" = "red")) +
  scale_fill_manual(values  = c("2023" = "steelblue", "2024" = "red")) +
  labs(x = "Total bathrooms (full + 0.5×half)",
       y = "Median assessed / sale price",
       title = "Median assessment ratio by bathroom group",
       subtitle = "Points = median (scaled by sample size); shaded band = bootstrap 95% CI") +
  theme_minimal(base_size = 12)
dev.copy2pdf(file = "figures/median_bathrooms.pdf", width = 7, height = 5)
# ============================================================================ #
# ROOM GROUPS 
# ============================================================================ #

room_levels <- c("≤4","5","6","7","8","≥9")

rooms_23 <- summarise_group_median(sold_2023, rooms_grp, resp = "ratio", levels = room_levels, year_label = "2023")
rooms_24 <- summarise_group_median(sold_2024, rooms_grp, resp = "ratio", levels = room_levels, year_label = "2024")
rooms_sum <- bind_rows(rooms_23, rooms_24) %>%
  mutate(x_num = as.numeric(rooms_grp))

ggplot(rooms_sum, aes(x = x_num, y = med, color = year, fill = year, group = year)) +
  geom_ribbon(aes(ymin = lo, ymax = hi), alpha = 0.15, color = NA) +
  geom_line(size = 0.8) +
  geom_point(aes(size = n), alpha = 0.8) +
  scale_size_continuous(range = c(2, 6), guide = "none") +
  geom_hline(yintercept = 0.70, linetype = 2, color = "firebrick") +
  scale_x_continuous(breaks = seq_along(room_levels), labels = room_levels) +
  scale_color_manual(values = c("2023" = "steelblue", "2024" = "red")) +
  scale_fill_manual(values  = c("2023" = "steelblue", "2024" = "red")) +
  labs(x = "Total rooms",
       y = "Median assessed / sale price",
       title = "Median assessment ratio by room group",
       subtitle = "Points = median (scaled by sample size); shaded band = bootstrap 95% CI") +
  theme_minimal(base_size = 12)

dev.copy2pdf(file = "figures/median_rooms.pdf", width = 7, height = 5)

```

```{r}
sold_2023_living <- sold_2023 %>% 
    filter(!is.na(living_area), living_area > 100)
sold_2024_living <- sold_2024 %>% 
    filter(!is.na(living_area), living_area > 100)

# Fir a log-log linear models
lm_living23 <- lm(log(ratio) ~ log(living_area), data = sold_2023_living)
lm_living24 <- lm(log(ratio) ~ log(living_area), data = sold_2024_living)

# Plot points and regression lines for 2023
plot(log(sold_2023_living$living_area), log(sold_2023_living$ratio), 
     xlab = "Living Area (log sq ft)", ylab = "Assessed / Sale Price (log)",
     pch = 19, col = alpha(rgb(0, 0, 1, 0.3),0.2), cex=0.6)
abline(lm_living23, col = "blue", lwd = 2.5)

# and 2024 on the same plot (transparent points)
points(log(sold_2024_living$living_area), log(sold_2024_living$ratio), 
       pch = 19, col = alpha(rgb(1, 0, 0, 0.3),0.2), cex=0.6)
abline(lm_living24, col = "red", lwd = 2.5)

abline(h = log(0.7), col = "black", lty = 2, lwd = 1.5)
legend("topright", legend = c("2023", "2024", "0.7 Line"), col = c("blue", "red", "black"), lty = c(1,1,2), lwd = c(2.5,2.5,1.5))

# save as pdf
dev.copy2pdf(file = "figures/living_area_loglog.pdf", width = 7, height = 5)

```

And let's look at the relationship between the assessed-sale ratio and the
sale price

```{r}
lm_sales23 <- lm(log(ratio) ~ log(sale_price), data = sold_2023)
lm_sales24 <- lm(log(ratio) ~ log(sale_price), data = sold_2024)

# Plot points and regression lines for 2023
plot(log(sold_2023$sale_price), log(sold_2023$ratio), 
     xlab = "Sale Price (log $)", ylab = "Assessed / Sale Price (log)",
     pch = 19, col = alpha(rgb(0, 0, 1, 0.3),0.2), cex=0.6)
abline(lm_sales23, col = "blue", lwd = 2.5)

# and 2024 on the same plot (transparent points)
points(log(sold_2024$sale_price), log(sold_2024$ratio), 
       pch = 19, col = alpha(rgb(1, 0, 0, 0.3),0.2), cex=0.6)
abline(lm_sales24, col = "red", lwd = 2.5)

abline(h = log(0.7), col = "black", lty = 2, lwd = 1.5)
legend("bottomright", legend = c("2023", "2024", "0.7 Line"), col = c("blue", "red", "black"), lty = c(1,1,2), lwd = c(2.5,2.5,1.5))

# save as pdf
dev.copy2pdf(file = "figures/sale_price_loglog.pdf", width = 7, height = 5)
```

# Hypothesis tests
Here we perform hypothesis test to check wether the median ratio is 
significantly different from 0.7

```{r}
# Let's first check if the normality assumption for t-test is satisfied
par(mfrow = c(1, 3))
qqnorm(sold_2009$ratio, main = "2009")
qqline(sold_2009$ratio, col = "red")
qqnorm(sold_2023$ratio, main = "2023")
qqline(sold_2023$ratio, col = "red")
qqnorm(sold_2024$ratio, main = "2024")
qqline(sold_2024$ratio, col = "red")

dev.copy2pdf(file = "figures/qqplots.pdf", width = 10, height = 3.5)

par(mfrow = c(1,1)) # restore the 1 plot layout
```

```{r}
# Since the three distributions are not normal, we do a nonparametric test 
# testing wheater the median ratio is significantly different from 0.7

w2009 <- wilcox.test(sold_2009$ratio, mu = 0.7, conf.int = TRUE)
w2023 <- wilcox.test(sold_2023$ratio, mu = 0.7, conf.int = TRUE)
w2024 <- wilcox.test(sold_2024$ratio, mu = 0.7, conf.int = TRUE)
w2009; w2023; w2024

ctest <- data.frame(NA, nrow = 3, ncol = 4)
colnames(ctest) <- c("estimate", "conf.low", "conf.high")
for (i in seq_along(list(w2009, w2023, w2024))) {
  df <- list(w2009, w2023, w2024)[[i]]
  ctest[i, ] <- c(df["estimate"]$estimate, df["conf.int"]$conf.int[1], df["conf.int"]$conf.int[2])
}
ctest$year <- c(2009, 2023, 2024)
ctest

plotCI(1:3, ctest$estimate, 
       ui = ctest$conf.high, li = ctest$conf.low, 
       pch = 19, col = "blue", xaxt = "n", xlab = "Year", ylab = "Assessed / Sale Price",)
abline(h = 0.7, col = "red", lty = 2)
axis(1, at = 1:3, labels = ctest$year)

dev.copy2pdf(file = "figures/wilcox_ci.pdf", width = 7, height = 5)
```

